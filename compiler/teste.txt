//arquivo compiler.h
    struct compile_process {
    // Como o arquivo deve ser compilado
    int flags;

    /* LAB2: Adicionar */
    struct pos pos;

    struct compile_process_input_file {
        FILE* fp;
        const char* abs_path;
    } cfile;

    struct vector* token_vec;       /* LAB3: Vetor de tokens da análise léxica */
    struct vector* node_vec;        /* LAB3: Vetor de nodes da análise sintatica */
    struct vector* node_tree_vec;   /* LAB3: Raiz da arvore de analise */

    FILE* ofile;
};




enum {
    NODE_TYPE_EXPRESSION,
    NODE_TYPE_EXPRESSION_PARENTHESIS,
    NODE_TYPE_NUMBER,
    NODE_TYPE_IDENTIFIER,
    NODE_TYPE_STRING,
    NODE_TYPE_VARIABLE,
    NODE_TYPE_VARIABLE_LIST,
    NODE_TYPE_FUNCTION,
    NODE_TYPE_BODY,
    NODE_TYPE_STATEMENT_RETURN,
    NODE_TYPE_STATEMENT_IF,
    NODE_TYPE_STATEMENT_ELSE,
    NODE_TYPE_STATEMENT_WHILE,
    NODE_TYPE_STATEMENT_DO_WHILE,
    NODE_TYPE_STATEMENT_FOR,
    NODE_TYPE_STATEMENT_BREAK,
    NODE_TYPE_STATEMENT_CONTINUE,
    NODE_TYPE_STATEMENT_SWITCH,
    NODE_TYPE_STATEMENT_CASE,
    NODE_TYPE_STATEMENT_DEFAULT,
    NODE_TYPE_STATEMENT_GOTO,
    NODE_TYPE_UNARY,
    NODE_TYPE_TENARY,
    NODE_TYPE_LABEL,
    NODE_TYPE_STRUCT,
    NODE_TYPE_UNION,
    NODE_TYPE_BRACKET,
    NODE_TYPE_CAST,
    NODE_TYPE_BLANK
};



enum {
    PARSE_ALL_OK,
    PARSE_GENERAL_ERROR
};

// Cada nó uma parte do inputfile.
struct node {
    int type;
    int flags;
    struct pos pos;

    struct node_binded {
        // Ponteiro para o body node.
        struct node* owner;

        // Ponteiro para a funcao que o no esta.
        struct node* funtion;
    } binded;

    // Estrutura similar ao token
    union {
        char cval;
        const char* sval;
        unsigned int inum;
        unsigned long lnum;
        unsigned long long llnum;
        void* any;
    };
};



// arquivo cprocess.c

#include "compiler.h"
#include "helpers/vector.h"    /* LAB3: Incluir */

struct compile_process* compile_process_create(const char* filename, const char* filename_out, int flags) {
    FILE *file = fopen(filename, "r");

    if (!file) {
        return NULL;
    }

    FILE* out_file = NULL;
    if (filename_out) {
        out_file = fopen(filename_out, "w");
        if (!out_file) {
            return NULL;
        }
    }

    struct compile_process* process = calloc(1, sizeof(struct compile_process));
    process->node_vec = vector_create(sizeof(struct node*));          /* LAB3: Inicializando o vetor */
    process->node_tree_vec = vector_create(sizeof(struct node*));     /* LAB3: Inicializando o vetor */
    process->flags = flags;
    process->cfile.fp = file;
    process->ofile = out_file;

    return process;
}





//arquivo compiler.c


int compile_file(const char* filename, const char* out_filename, int flags) {
    struct compile_process* process = compile_process_create(filename, out_filename, flags);
    if (!process) {
        return COMPILER_FAILED_WITH_ERRORS;
    }

    /* AQUI ENTRA A ANÁLISE LÉXICA */
    struct lex_process* lex_process = lex_process_create(process, &compiler_lex_functions, NULL);

    if (!lex_process) return COMPILER_FAILED_WITH_ERRORS;

    if (lex(lex_process) != LEXICAL_ANALYSIS_ALL_OK) return COMPILER_FAILED_WITH_ERRORS;

    process->token_vec = lex_process->token_vec;  /* LAB3: Adicionar */

    /* AQUI ENTRA O PARSING DO CÓDIGO */
    if (parse(process) != PARSE_ALL_OK) return COMPILER_FAILED_WITH_ERRORS;  /* LAB3: Adicionar */

    /* AQUI ENTRA A GERAÇÃO DE CÓDIGO */

    return COMPILER_FILE_COMPILED_OK;
}
