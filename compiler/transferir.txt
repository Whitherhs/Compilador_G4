#define OPERATOR_CASE \
    case '+': \
    case '-': \
    case '*': \
    case '>': \
    case '<': \
    case '^': \
    case '%': \
    case '|': \
    case '=': \
    case '~': \
    case '&': \
    case '(': \
    case '[': \
    case '.': \
    case ':': \
    case '?'

static struct token *token_make_operator_or_string()
{
    char op = peekc();
    // Tratar o caso do #include <abc.h>
    if (op == '<') {
        struct token* last_token = lexer_last_token();
        if (token_is_keyword(last_token, "include")) {
            return token_make_string('<', '>');
        }
    }

    struct token* token = token_create(&(struct token){.type = TOKEN_TYPE_STRING, .sval = read_op()});
    if (op == '(') {
        lex_new_expression();
    }

    return token;
}

#define SYMBOL_CASE \
    case '{': \
    case '}': \
    case ':': \
    case ';': \
    case '#': \
    case '\\': \
    case ')': \
    case ']'

static void lex_new_expression() {
    lex_process->current_expression_count++;
    if (lex_process->current_expression_count == 1) {
        lex_process->parentheses_buffer = buffer_create();
    }
}

static void lex_fisish_expression() {
    lex_process->current_expression_count--;

    if (lex_process->current_expression_count < 0) {
        compiler_error(lex_process->compiler, "Voce fechou uma expressao nunca iniciada!\n");
    }
}

bool lex_is_in_expresssion() {
    return lex_process->current_expression_count > 0;
}

static struct token* token_make_symbol() {
    char c = nextc();
    if (c == ')') {
        lex_fisish_expression();
    }

    struct token* token = token_create(&(struct token){.type=TOKEN_TYPE_SYMBOL, .cval=c});
    printf("Token: %c\n", c);
    return token;
}

static struct token *token_make_string(char start_delim, char end_delim)
{
    struct buffer *buf = buffer_create();
    assert(nextc() == start_delim); // verifica se o caracter inicial eh aspas duplas
    char c = nextc();

    for (; c != end_delim && c != EOF; c = nextc())
    {
        if (c == '\\')
        { // Retira o enter do final da string (se tiver).
            continue;
        }
        buffer_write(buf, c);
    }
    buffer_write(buf, 0x00);
    printf("Token: %s\n", buf->data);

    struct token* token = token_create(&(struct token){.type = TOKEN_TYPE_STRING, .sval = buffer_ptr(buf)});
    return token;
}

struct token* token_make_one_line_comment() {
    struct buffer* buffer = buffer_create();
    char c = 0;
    LEX_GETC_IF(buffer, c, c != '\n' && c != EOF);
    return token_create(&(struct token){.type = TOKEN_TYPE_COMMENT, .sval=buffer_ptr(buffer)});
}

struct token* token_make_multiline_comment() {
    struct buffer* buffer = buffer_create();
    char c = 0;
    while(1) {
        LEX_GETC_IF(buffer, c, c != '*' && c != EOF);

        if (c == EOF) {
            compiler_error(lex_process->compiler, "O comentario nao foi fechado\n");
        } else if (c == '*') {
            nextc(); // Pula para o próximo caractere do arquivo.

            if (peekc() == '/') {
                // Finaliza o comentário
                nextc();
                break;
            }
        }
    }

    return token_create(&(struct token){.type = TOKEN_TYPE_COMMENT, .sval=buffer_ptr(buffer)});
}

struct token* handle_comment() {
    char c = peekc();
    if (c == '/') {
        nextc();
        if (peekc() == '/') {
            nextc();
            return token_make_one_line_comment();
        } else if (peekc() == '*') {
            nextc();
            return token_make_multiline_comment();
        }

        pushc('/');
        return token_make_operator_or_string();
    }

    return NULL;
}

struct token* token_make_newline() {
    nextc();
    return token_create(&(struct token){.type=TOKEN_TYPE_NEWLINE});
}
